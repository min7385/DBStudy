/*
뷰 View 338p
하나 이상의 테이블을 연결해 마치 테이블인 것처럼 사용하는 객체
실제 데이터는 뷰를 구성하는 테이블에 담겨 있지만 테이블처럼 사용 가능
사용목적: 1. 자주 사용하는 SQL문을 매번 작성할 필요 없이 뷰로 생성하여 사용 가능
         2. 데이터 보안 측면(원천 테이브을 감출 수 있음)
뷰 특징: (1) 단순 뷰(테이블 1개)
            - 그룹함수 사용 불가
            - distinct 사용 불가
            - insert/update/delete 사용 가능
        (2) 복합 뷰(여러 개 테이블)
            - 그룹함수 사용 가능
            - distinct 사용 가능
            - insert/update/delete 불가능
*/
CREATE OR REPLACE VIEW emp_dep AS
SELECT a.employee_id
    , a.emp_name
    , b.department_id
    , b.department_name
FROM employees a, departments b
WHERE a.department_id = b.department_id;
-- system 계정에서 java계정에 뷰를 생성할 수 있는 권한 부여
GRANT CREATE VIEW TO java;
SELECT *
FROM emp_dep;
-- java계정에서 emp_dep view를 조회할 수 있는 권한을 study계정에게 부여함.
GRANT SELECT ON emp_dep TO study;
-- study 계정에서 조회
SELECT *
FROM java.emp_dep;
-- view 삭제
DROP view emp_dep;

/* 동의어(Synonim)
   시노님은 동의어란 뜻으로 객체 각자의 고유한 이름에 대한 동의어를 만드는 것
   public synonim 모든 사용자 접근
   private synonim 특정 사용자만 접근
   public synonim은 DBA 권한이 있는 사용자만 가능(생성, 삭제)
   목적: 1. 보안측면 계정명(id), 테이블명과 같은 중요한 정보를 숨기기 위해 별칭을 만듬
         2. 개발 편의성 실제 테이블의 정보가 변경되어도 별칭으로 사용했다면 코드수정 안해도됨
*/
-- system 계정에서 시노님 생성 권한 부여
GRANT CREATE SYNONYM TO member;
-- member 계정에서 member 테이블
-- default private synonym
CREATE OR REPLACE SYNONYM mem FOR member; -- member 테이블을 mem으로
-- java 계정에서 mem 조회할 수 있는 권한 부여
GRANT SELECT ON mem TO java;
SELECT *
FROM member.mem;
-- system 계정에서 public synonym 생성(member 계정의 member 테이블)
CREATE OR REPLACE PUBLIC SYNONYM mem2 FOR member.member;
GRANT SELECT ON mem2 TO study;
SELECT *
FROM mem2;
-- 권한 해제
-- REVOKE 권한 FROM 계정명
-- public synonym 삭제는 DBA 권한이 있어야 함.
DROP PUBLIC SYNONYM mem2;

/* 시퀸스 sequence: 규칙에 따라 자동 순번을 반환하는 객체
   목적: pk로 사용할 컬럼이 없는 경우
   시퀀스명.CURRVAL (현재 시퀀스 값) 최초에는 없기 때문에 안됨.
   시퀀스명.NEXTVAL 다음 시퀀스 값
*/
CREATE SEQUENCE my_seq
INCREMENT BY 1 -- 증강숫자
START WITH 1    -- 시작숫자
MINVALUE 1      -- 최소값
NOCYCLE 10      -- 최대값
NOCYCLE         -- 최대나 최소에 도달하면 생성중지(cycle은 다시 돌아감)
NOCACHE;        -- 메모리에 최대 시퀀스 값을 할당 할지말지(cache = 할당함)
SELECT my_seq.NEXTVAL -- << 실행할수록 증가 1, 2, 3 ... 10
FROM dual;
SELECT my_seq.CURRVAL
FROM dual; -- << 현재 값 조회
--
CREATE SEQUENCE my_seq2
INCREMENT BY 10 -- 증강숫자
START WITH 1000    -- 시작숫자
MINVALUE 1      -- 최소값
NOCYCLE 99999999;      -- 최대값
SELECT my_seq.NEXTVAL
FROM dual;
--
CREATE TABLE ex11(
    dep_seq NUMBER PRIMARY KEY
    ,dt     DATE DFFAULT SYSDATE);
INSERT INTO ex11 (dep_seq) VALUES (my_seq2.NEXTVAL);
INSERT INTO ex11 (dep_seq) VALUES ((SELECT MAX(NVL(dep_seq,0)) +10
FROM ex11));
SELECT * FROM ex11;

SELECT MAX(NVL(dep_seq,0)) +10
FROM ex11;

-- oracle 12버전부터 사용 가능
-- IDENTITY(테이블 생성 시 사용 가능)
CREATE TABLE ex11_1(
    seq NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY
    , title VARCHAR2(100)
);
INSET INTO ex11_1 (title) VALUES ('ha ha');
SELECT *
FROM ex11_1;
CREATE TABLE ex11_2 (
    seq NUMBER GENERATED BY DEFAULT AS IDENTITY(
        START WITH 100
        INCREMENT BY 10
        MINVALUE 10
        MAXVALUE 1000000
        ) PRIMARY KEY
    , title VARCHAR2(100)
);
INSERT INTO ex11_2(title) VALUES('하이');
SELECT * FROM ex11_2;

-- 세미조인?
-- EXISTS 서브쿼리에서 결과가 하나라도 존재하면 True, 없으면 False를 반환
-- 서브쿼리의 결과가 존재하는지 여부를 확인하는데 사용됨.
-- 수강이력이 있는(존재하는) 학생 조회
SELECT *
FROM 학생 a
WHERE EXISTS (SELECT *
              FROM 수강내역
              WHERE 학번 = a.학번); -- ()안에 True인 얘들을 학생 table에서 조회
              
/* MERGE
   UPDATE or DELETE와 INSERT를 한 번에 처리할 수 있는 SQL문
*/
-- '과목' 테이블에 머신러닝 과목이 있으면 학점을 3으로 업데이트
--                              없으면 INSERT('머신러닝', 학점: 2)
SELECT *
FROM 과목;      -- 머신러닝 없는거 확인
MERGE INTO 과목 s  -- 대상테이블
   USING DUAL      -- 조건테이블(dual은 대상테이블을 조건으로 할 때)
   ON (s.과목이름 = '머신러닝')  -- matched 조건
WHEN MATCHED THEN
   UPDATE SET s.학점 = 3
WHEN NOT MATCHED THEN
   INSERT (과목번호, 과목이름, 학점)
   VALUES ((SELECT MAX(과목번호) +1
           FROM 과목), '머신러닝', 2);